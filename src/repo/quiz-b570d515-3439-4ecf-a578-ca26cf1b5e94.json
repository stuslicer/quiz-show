{"id":"b570d515-3439-4ecf-a578-ca26cf1b5e94","name":"threads","description":"threads","difficulty":"simple","tags":[],"aiPromptUsed":"threads","aiEngine":"openAI","model":"GPT_4_TURBO","generatedOn":"2024-06-18T11:06:46.6174353","lastUpdatedOn":"2024-06-18T11:06:46.6244373","questions":[{"number":1,"text":"What is the purpose of the 'synchronized' keyword in Java?","options":[{"text":"To provide automatic scaling of applications","isCorrect":false,"explanation":"The 'synchronized' keyword doesn't affect scaling; it's used for thread safety."},{"text":"To improve the performance of multithreaded applications","isCorrect":false,"explanation":"Synchronization can actually decrease performance due to overhead but is necessary for thread safety."},{"text":"To prevent thread interference and memory consistency errors","isCorrect":true,"explanation":"The 'synchronized' keyword ensures that only one thread can execute a method or block at a time, preventing these issues."},{"text":"To notify threads waiting on an object's monitor","isCorrect":false,"explanation":"'notify()' or 'notifyAll()' methods are used for notifying waiting threads, not the 'synchronized' keyword."}]},{"number":2,"text":"What does the 'volatile' keyword ensure?","options":[{"text":"That a variable's value will be modified by multiple threads.","isCorrect":false,"explanation":"Volatile does not ensure modification by multiple threads; it ensures visibility of changes to variables across threads."},{"text":"That a variable is synchronized across all threads.","isCorrect":true,"explanation":"Volatile guarantees that a variable's value will be read from and written to main memory, ensuring visibility of its updates to other threads."},{"text":"That a method can be accessed by only one thread at a time.","isCorrect":false,"explanation":"Volatile applies to variables, not methods; synchronization controls method access."},{"text":"That the variable can only be used within synchronized blocks.","isCorrect":false,"explanation":"Volatile variables can be used outside of synchronized blocks; they simply provide a lighter-weight synchronization mechanism than 'synchronized'."}]},{"number":3,"text":"Which method wakes up all threads waiting on the object's monitor?","options":[{"text":"wait()","isCorrect":false,"explanation":"The 'wait()' method causes the current thread to wait, not to wake up others."},{"text":"notify()","isCorrect":false,"explanation":"'notify()' wakes up only one single thread waiting on the object’s monitor."},{"text":"notifyAll()","isCorrect":true,"explanation":"'notifyAll()' wakes up all threads that are waiting on the object’s monitor."},{"text":"sleep()","isCorrect":false,"explanation":"'sleep()' makes the current thread sleep, it has no effect on other threads."}]},{"number":4,"text":"What best describes a deadlock in a multithreaded application?","options":[{"text":"When a thread is waiting for an object lock that never gets released","isCorrect":false,"explanation":"While this situation is related, it describes a lock starvation rather than a deadlock."},{"text":"When the thread scheduler suspends all threads","isCorrect":false,"explanation":"This does not describe deadlock, which is a specific condition caused by mutual exclusive locking."},{"text":"When two or more threads are waiting forever for each other to release resources they need","isCorrect":true,"explanation":"This is the definition of a deadlock, where multiple threads are each waiting on the other to release a resource, creating a cycle of dependencies."},{"text":"When a thread throws an InterruptedException","isCorrect":false,"explanation":"InterruptedException is thrown when a thread is interrupted, typically via the 'interrupt()' method, and not related to deadlocks."}]},{"number":5,"text":"What is the primary concern when using the 'Thread.stop()' method?","options":[{"text":"It may cause deadlock.","isCorrect":false,"explanation":"While resource locking issues may occur, 'Thread.stop()' is primarily problematic for other reasons."},{"text":"It is a deprecated method and may result in incomplete task execution.","isCorrect":true,"explanation":"'Thread.stop()' is deprecated because it can leave objects in an inconsistent state by stopping tasks abruptly without proper cleanup."},{"text":"It increases the performance of the application.","isCorrect":false,"explanation":"Stopping a thread abruptly is likely to decrease, not increase, performance due to potential resource locking and inconsistency issues."},{"text":"It automatically releases all object locks.","isCorrect":false,"explanation":"'Thread.stop()' may leave locks in place, leading to potential deadlocks or other synchronization problems."}]},{"number":6,"text":"Which of the following is true about the 'Thread.sleep()' method?","options":[{"text":"It releases the monitor lock of the object it's called on.","isCorrect":false,"explanation":"'Thread.sleep()' does not release any locks the thread might hold."},{"text":"It guarantees precise timing of when a thread will wake up.","isCorrect":false,"explanation":"The actual timing can be affected by system timing and scheduling variances."},{"text":"It can throw an InterruptedException if another thread interrupts it.","isCorrect":true,"explanation":"If any thread has interrupted the current thread, the sleep method throws an InterruptedException."},{"text":"It ensures thread safety for shared resources.","isCorrect":false,"explanation":"Sleeping a thread does not deal with the mechanism of thread safety for shared resources."}]},{"number":7,"text":"What is the purpose of the 'join()' method in threading?","options":[{"text":"It forces all threads to execute in a sequential, synchronized order.","isCorrect":false,"explanation":"'join()' is used to make one thread wait for the completion of another, not to order multiple threads sequentially."},{"text":"It allows a thread to wait for the completion of another thread.","isCorrect":true,"explanation":"The 'join()' method allows one thread to wait until another thread completes its execution."},{"text":"It ensures that the CPU gives the same execution time to all threads.","isCorrect":false,"explanation":"Thread scheduling and CPU time slicing are managed by the thread scheduler, not by 'join()'."},{"text":"It is used to start a thread.","isCorrect":false,"explanation":"The 'start()' method is used to start a thread, not 'join()'."}]},{"number":8,"text":"How does the 'wait()' method handle the monitor of the object it's called upon?","options":[{"text":"It causes the current thread to permanently give up the monitor.","isCorrect":false,"explanation":"The monitor is temporarily released but reacquired when the thread is awakened."},{"text":"It does not release the monitor.","isCorrect":false,"explanation":"'wait()' always releases the monitor."},{"text":"It releases the monitor and allows other threads to acquire it.","isCorrect":true,"explanation":"When 'wait()' is called, the current thread releases the monitor and waits until another thread notifies it or interrupts it."},{"text":"It synchronizes all threads that are waiting for the monitor.","isCorrect":false,"explanation":"'wait()' does not synchronize threads; it places the current thread into the 'waiting' state."}]},{"number":9,"text":"What happens when the 'interrupt()' method is called on a thread that is waiting or sleeping?","options":[{"text":"The thread is terminated immediately.","isCorrect":false,"explanation":"'interrupt()' does not terminate a thread; it sets the thread's interrupt status."},{"text":"The thread continues to wait or sleep until its wait or sleep time completes.","isCorrect":false,"explanation":"Calling 'interrupt()' on a sleeping or waiting thread causes an InterruptedException to be thrown, potentially ending that state prematurely."},{"text":"The thread immediately exits the waiting or sleeping state and throws an InterruptedException.","isCorrect":true,"explanation":"When 'interrupt()' is called on a thread in a waiting or sleeping state, it throws InterruptedException, causing it to exit that state."},{"text":"The thread's priority is increased to the maximum value.","isCorrect":false,"explanation":"Interrupting a thread does not affect its priority setting."}]},{"number":10,"text":"Which statement is true about the 'ExecutorService' in Java?","options":[{"text":"It is primarily used to handle low-level threading and synchronization tasks.","isCorrect":false,"explanation":"ExecutorService abstracts away low-level threading, focusing on managing a pool of threads and task execution."},{"text":"It does not provide any mechanism to manage or control thread life cycles.","isCorrect":false,"explanation":"ExecutorService provides methods to manage the lifecycle of tasks and control thread execution."},{"text":"It can be used to execute Runnable or Callable tasks asynchronously.","isCorrect":true,"explanation":"ExecutorService can manage asynchronous task execution, handling Runnable or Callable objects."},{"text":"It automatically prioritizes tasks based on their runtime complexity.","isCorrect":false,"explanation":"ExecutorService does not prioritize tasks based on complexity; task execution order and prioritization depend on the implementation and configuration."}]}]}